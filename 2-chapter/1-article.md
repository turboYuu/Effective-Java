# 第1条 用静态工厂代替构造器

对于类而言，为了让客户端获取它自身的一个实例，最传统的方法就是提供一个公有的构造器。还有一种方法，也应该在每个程序员的工具箱中占有一席之地。类可以提供一个公有的*静态工厂方法*（static factory method），它只是返回一个类的实例静态方法。下面是一个来自**Boolean**（基本类型 boolean 的装箱类）的简单示例。这个方法将boolean基本类型值装换成一个 Boolean 对象的引用：

```java
public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
}
```

注意，静态工厂方法与设计模式 [ Gamma95 ] 中的工厂方法（Factory Method）模式不同，本条目中所指的静态工厂方法不直接对应于设计模式（Design Pettern）中的工厂方法。

如果不通过公有的构造器，或者说除了公有的构造器之外，类还可以给它的客户端提供静态工厂方法。提供静态工厂方法而不是共有的构造器，这样做既有优势，也有劣势。

**静态工厂方法与构造器不同的第一大优势在于，它们有名称**。如果构造器的参数本身没有确切的描述正被返回的对象，那么适当名称的静态工厂更容器使用，产生的客户端代码也更易于阅读。例如 `BigInteger(int, int, Random)` 返回的 BigInteger 可能为素数，如果使用名为 `BigInteger.probablePrime` 的静态工厂方法来表示，显然更为清楚。（Java 4 版本中增加了这个方法。）

一个类只能有一个带有指定签名的构造器。编程人员通常知道如何避开这一限制：通过提供两个构造器，它们的参数列表只在参数类型上的顺序有所不同。实际上这并不是个好的主意。面对这样的API，用户永远也记不住该用哪个构造器，结果常常会调用错误的构造器。并且在阅读到使用了这些构造器的代码时，如果没有参考类的文档，往往不知所云。

**由于静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象**。这使得不可变类（详见第17条）可以使用预先建好的实例，或者将构建好的实例缓存起来，进行重复利用，从而避免创建不必要的重复对象。Boolean.valueOf(boolean)说明了这项技术：它从来不创建对象。这种方法类似于 ***享元*** （Flyweight）模式 [Gamma95]。如果程序经常请求创建相同的对象，并且这种创建对象的代价很高，则这项技术可以极大地提升性能。

静态工厂方法能够为重复地调用返回相同对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在。这种类被称作 *实例受控制的类*（instance-controlled）。

